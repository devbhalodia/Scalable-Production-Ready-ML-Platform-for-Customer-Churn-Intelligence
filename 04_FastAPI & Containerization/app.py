# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HuiA7ZzfzEwp3CEONz7Wa-_3vkQrbyky
"""

from pydantic import BaseModel, Field, field_validator
from typing import List, Dict, Optional, Annotated
from dotenv import load_dotenv
load_dotenv()


class User(BaseModel):
    customer_age: Annotated[int, Field(gt=0, lt=120)]
    gender: str
    dependent_count: int
    education_level: str
    marital_status: str
    income_category: str
    card_category: str
    months_on_book: Annotated[int, Field(gt=11, lt=60)]
    total_relationship_count: Annotated[int, Field(gt=0, lt=10)]
    months_inactive_12_mon: Annotated[int, Field(ge=0)]
    contacts_count_12_mon: Annotated[int, Field(ge=0)]
    credit_limit: Annotated[float, Field(gt=0)]
    total_revolving_bal: Annotated[float, Field(ge=0)]
    avg_open_to_buy: Annotated[float, Field(ge=0)]
    total_amt_chng_q4_q1: Annotated[float, Field(ge=0)]
    total_trans_amt: Annotated[int, Field(ge=0)]
    total_trans_ct: Annotated[int, Field(ge=0)]
    total_ct_chng_q4_q1: Annotated[float, Field(ge=0)]
    avg_utilization_ratio: Annotated[float, Field(ge=0, le=1)]

    @field_validator("gender")
    @classmethod
    def valid_gender(cls, v):
        allowed = {
            "m", "f"
        }
        if v.strip().lower() not in allowed:
            raise ValueError("Invalid gender value")
        return v.lower()

    @field_validator("education_level")
    @classmethod
    def valid_education_level(cls, v):
        allowed = {
            "unknown", "uneducated", "high school", "college", "graduate", "post-graduate", "doctorate"
        }
        if v.strip().lower() not in allowed:
            raise ValueError("Invalid education level value")
        return v.lower()

    @field_validator("marital_status")
    @classmethod
    def valid_marital_status(cls, v):
        allowed = {
            "married", "single", "divorced", "unknown"
        }
        if v.strip().lower() not in allowed:
            raise ValueError("Invalid marital status value")
        return v.lower()

    @field_validator("income_category")
    @classmethod
    def valid_income_category(cls, v):
        allowed = {
            "unknown", "less than $40k", "$40k - $60k", "$60k - $80k", "$80k - $120k", "$120k +"
        }
        if v.strip().lower() not in allowed:
            raise ValueError("Invalid income category value")
        return v.lower()

    @field_validator("card_category")
    @classmethod
    def valid_card_category(cls, v):
        allowed = {
            "blue", "silver", "gold", "platinum"
        }
        if v.strip().lower() not in allowed:
            raise ValueError("Invalid card category value")
        return v.lower()

from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, computed_field
from typing import Literal, Annotated
import joblib
import pandas as pd
import boto3
import tarfile
import os
from preprocessing import TextStandardizer, CategoricalCaster

BUCKET_NAME = os.environ.get("MODEL_BUCKET")
MODEL_KEY = os.environ.get("MODEL_KEY")
LOCAL_ARCHIVE = "model.tar.gz"
EXTRACTED_MODEL = "model.joblib" # Name inside the tar.gz

def load_model_from_s3():
    s3 = boto3.client(
        "s3",
        region_name=os.environ.get("AWS_REGION")
    )

    if not BUCKET_NAME or not MODEL_KEY:
        raise RuntimeError("S3 env vars not set")

    s3.download_file(BUCKET_NAME, MODEL_KEY, "/tmp/model.tar.gz")

    with tarfile.open("/tmp/model.tar.gz", "r:gz") as tar:
        tar.extractall("/tmp/model")

    for root, _, files in os.walk("/tmp/model"):
        for f in files:
            if f.endswith(".joblib"):
                return joblib.load(os.path.join(root, f))

    raise FileNotFoundError("Model file not found in archive")


model = None

app = FastAPI()

@app.on_event("startup")
def startup_event():
    global model
    try:
        model = load_model_from_s3()
        print("Model loaded successfully")
    except Exception as e:
        print("Model failed to load:", str(e))
        model = None


@app.post("/predict")
def predict(user: User):
    if model is None:
        raise HTTPException(status_code=503, detail="Model not loaded")
    
    try:
        data = pd.DataFrame([user.model_dump()])
        pred = model.predict(data)[0]
        prob = model.predict_proba(data)[0][1]

        return {
            "attrition_prediction": int(pred),
            "attrition_probability": round(float(prob), 4)
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))