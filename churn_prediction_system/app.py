# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HuiA7ZzfzEwp3CEONz7Wa-_3vkQrbyky
"""

from pydantic import BaseModel, EmailStr, AnyUrl, Field, field_validator
from typing import List, Dict, Optional, Annotated

class User(BaseModel):
    customer_age: Annotated[int, Field(gt=0, lt=120)]
    gender: str
    dependent_count: int
    education_level: str
    marital_status: str
    income_category: str
    card_category: str
    months_on_book: Annotated[int, Field(gt=11, lt=60)]
    total_relationship_count: Annotated[int, Field(gt=0, lt=10)]
    months_inactive_12_mon: Annotated[int, Field(ge=0)]
    contacts_count_12_mon: Annotated[int, Field(ge=0)]
    credit_limit: Annotated[float, Field(gt=0)]
    total_revolving_bal: Annotated[float, Field(gt=0)]
    avg_open_to_buy: Annotated[float, Field(gt=0)]
    total_amt_chng_q4_q1: Annotated[float, Field(ge=0)]
    total_trans_amt: Annotated[int, Field(ge=0)]
    total_trans_ct: Annotated[int, Field(ge=0)]
    total_ct_chng_q4_q1: Annotated[float, Field(ge=0)]
    avg_utilization_ratio: Annotated[float, Field(ge=0, le=1)]

    @field_validator("gender")
    @classmethod
    def valid_gender(cls, v):
        allowed = {
            "m", "f"
        }
        if v.strip().lower() not in allowed:
            raise ValueError("Invalid gender value")
        return v.lower()

    @field_validator("education_level")
    @classmethod
    def valid_education_level(cls, v):
        allowed = {
            "unknown", "uneducated", "high school", "college", "graduate", "post-graduate", "doctorate"
        }
        if v.strip().lower() not in allowed:
            raise ValueError("Invalid education level value")
        return v.lower()

    @field_validator("marital_status")
    @classmethod
    def valid_marital_status(cls, v):
        allowed = {
            "married", "single", "divorced", "unknown"
        }
        if v.strip().lower() not in allowed:
            raise ValueError("Invalid marital status value")
        return v.lower()

    @field_validator("income_category")
    @classmethod
    def valid_income_category(cls, v):
        allowed = {
            "unknown", "less than $40k", "$40k - $60k", "$60k - $80k", "$80k - $120k", "$120k +"
        }
        if v.strip().lower() not in allowed:
            raise ValueError("Invalid income category value")
        return v.lower()

    @field_validator("card_category")
    @classmethod
    def valid_card_category(cls, v):
        allowed = {
            "blue", "silver", "gold", "platinum"
        }
        if v.strip().lower() not in allowed:
            raise ValueError("Invalid card category value")
        return v.lower()

input_data = {
    "customer_age": '35',
    "gender": "M",
    "dependent_count": 2,
    "education_level": "college",
    "marital_status": "married",
    "income_category": "$60k - $80k",
    "card_category": "gold",
    "months_on_book": 36,
    "total_relationship_count": 5,
    "months_inactive_12_mon": 1,
    "contacts_count_12_mon": 3,
    "credit_limit": 15000.0,
    "total_revolving_bal": 2000.0,
    "avg_open_to_buy": 13000.0,
    "total_amt_chng_q4_q1": 1.2,
    "total_trans_amt": 500,
    "total_trans_ct": 20,
    "total_ct_chng_q4_q1": 1.0,
    "avg_utilization_ratio": 0.13
}

from pydantic import ValidationError

try:
    user = User(**input_data)
    print("Validation successful!")
    print(user)
except ValidationError as e:
    print("Validation failed:")
    print(e.json())

from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, computed_field
from typing import Literal, Annotated
import joblib
import pandas as pd
from preprocessing import TextStandardizer, CategoricalCaster


model = joblib.load("models/xgb_churn_pipeline.pkl")

app = FastAPI()

@app.post("/predict")
def predict(user: User):
    try:
        # Convert validated input â†’ DataFrame
        data = pd.DataFrame([user.model_dump()])

        # Prediction
        pred = model.predict(data)[0]
        prob = model.predict_proba(data)[0][1]

        return {
            "attrition_prediction": int(pred),
            "attrition_probability": round(float(prob), 4)
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))